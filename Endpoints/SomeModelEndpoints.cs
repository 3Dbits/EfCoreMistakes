using EfCoreMistakes.Data;
using EfCoreMistakes.Models;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.EntityFrameworkCore;

namespace EfCoreMistakes.Endpoints;

public static class SomeModelEndpoints
{
    public static void MapSomeModelEndpoints(this IEndpointRouteBuilder routes)
    {
        var group = routes.MapGroup("/api/SomeModel").WithTags(nameof(SomeModel));

        group.MapGet("/", async (EfCoreMistakesContext db) =>
        {
            return await db.SomeModel.ToListAsync();
        })
        .WithName("GetAllSomeModels")
        .WithOpenApi();

        group.MapGet("/{id}", async Task<Results<Ok<SomeModel>, NotFound>> (int id, EfCoreMistakesContext db) =>
        {
            return await db.SomeModel.AsNoTracking()
                .FirstOrDefaultAsync(model => model.Id == id)
                is SomeModel model
                    ? TypedResults.Ok(model)
                    : TypedResults.NotFound();
        })
        .WithName("GetSomeModelById")
        .WithOpenApi();

        group.MapPut("/{id}", async Task<Results<Ok, NotFound>> (int id, SomeModel someModel, EfCoreMistakesContext db) =>
        {
            var affected = await db.SomeModel
                .Where(model => model.Id == id)
                .ExecuteUpdateAsync(setters => setters
                    .SetProperty(m => m.Id, someModel.Id)
                    .SetProperty(m => m.Title, someModel.Title)
                    );
            return affected == 1 ? TypedResults.Ok() : TypedResults.NotFound();
        })
        .WithName("UpdateSomeModel")
        .WithOpenApi();

        group.MapPost("/", async (SomeModel someModel, EfCoreMistakesContext db) =>
        {
            db.SomeModel.Add(someModel);
            await db.SaveChangesAsync();
            return TypedResults.Created($"/api/SomeModel/{someModel.Id}", someModel);
        })
        .WithName("CreateSomeModel")
        .WithOpenApi();

        group.MapDelete("/{id}", async Task<Results<Ok, NotFound>> (int id, EfCoreMistakesContext db) =>
        {
            var affected = await db.SomeModel
                .Where(model => model.Id == id)
                .ExecuteDeleteAsync();
            return affected == 1 ? TypedResults.Ok() : TypedResults.NotFound();
        })
        .WithName("DeleteSomeModel")
        .WithOpenApi();

        group.MapGet("/firstordefault", async (EfCoreMistakesContext db) =>
        {
            // This is a common mistake, it will fetch all records from the database and then filter them in memory
            // Comment on top is wrong (generated by Copilot)
            // Example where we fetch records with Title length greater than 2
            // Result is the same in both cases
            var testWhere = db.SomeModel.Where(sm => sm.Title.Length > 2).FirstOrDefault();

            var testFirst = db.SomeModel.FirstOrDefault(sm => sm.Title.Length > 2);

            // get in memory list
            var allModels = await db.SomeModel.ToListAsync();
            // First Where method is called to do work, then FirstOrDefault is called to get the first record
            var testWhere2 = allModels.Where(sm => sm.Title.Length > 2).FirstOrDefault();
            // FirstOrDefault method is called to do work and it's passing predicate
            var testFirst2 = allModels.FirstOrDefault(sm => sm.Title.Length > 2);
        })
        .WithName("FirstOrDefault")
        .WithOpenApi();

        group.MapGet("/bufferingvsstreaming", async (EfCoreMistakesContext db) =>
        {
            // ToList and ToArray cause the entire resultset to be buffered:
            var modelList = db.SomeModel.Where(sm => sm.Title.StartsWith("S")).ToList();
            var modelArray = db.SomeModel.Where(sm => sm.Title.StartsWith("S")).ToArray();

            // Foreach streams, processing one row at a time:
            foreach (var subModel in db.SubModel
                                            .Where(sm => sm.Information.StartsWith("S"))
                                            .AsNoTracking())
            {
                // ...
            }
            await foreach (var subModel in db.SubModel
                                                .Where(sm => sm.Information.StartsWith("S"))
                                                .AsNoTracking()
                                                .AsAsyncEnumerable())
            {
                // This will stream data more efficiently
            }
            // BonusTip: with anonymous type EF core is not tracking changes to that entity
            // Even better is to use strongly type object to map into
            foreach (var subModel in db.SubModel
                                            .Where(sm => sm.Information.StartsWith("S"))
                                            .Select(sm => new { sm.Id, sm.Information}))
            {
                // ...
            }

            var bufferedFilter = db.SomeModel
                .Where(p => p.Title.StartsWith("S"))
                .ToList() // Buffers all results here
                .Where(p => SomeDotNetMethod(p));

            var streamedFilter = db.SomeModel
                .Where(p => p.Title.StartsWith("S"))
                .AsEnumerable() // Streaming request
                .Where(p => SomeDotNetMethod(p));

            // True streaming behavior depends on both EF Core's query translation and how your database handles the query.
            // Always profile and test with realistic data volumes to ensure optimal performance.
        })
        .WithName("BufferingVsStreaming")
        .WithOpenApi();

        group.MapGet("/parameterization", async (EfCoreMistakesContext db) =>
        {
            // two same querys to DB
            var model1 = db.SomeModel.FirstOrDefault(p => p.Title == "SomeModel 1");
            var model2 = db.SomeModel.FirstOrDefault(p => p.Title == "SomeModel 2");

            // EF core automatically parameterizes the query before sending it to the database
            // making the query more efficient and secure
            var modelTitle = "SomeModel 1";
            var model3 = db.SomeModel.FirstOrDefault(p => p.Title == modelTitle);

            modelTitle = "SomeModel 2";
            var model4 = db.SomeModel.FirstOrDefault(p => p.Title == modelTitle);
            // Benefits:
            // Performance: Parameterized queries are more efficient because the database can
            //  cache the execution plan and reuse it for different parameter values.
            // Security: By parameterizing inputs, EF Core helps protect against SQL injection
            //  attacks, as the input values are treated as parameters rather than executable code.

            // Tip: Avoid string concatenation in queries: Always prefer parameterized queries over
            //  concatenating strings to form SQL queries, as concatenation is prone to SQL injection.
        })
        .WithName("Parameterization")
        .WithOpenApi();

        group.MapGet("/lazyloading", async (EfCoreMistakesContext db) =>
        {
            var models = db
                .SomeModel
                .OrderByDescending(x => x.Title);

            foreach (var model in models)
            {
                // a database call per SubModel
                foreach (var submodel in model.SubModels)
                {
                    // database call for SubSubModel
                     Console.WriteLine(submodel.SubSubModels.Count);
                }
            }
        })
        .WithName("LazyLoading")
        .WithOpenApi();

        group.MapGet("/cartesianexplosion", async (EfCoreMistakesContext db) =>
        {
            var someModels = db
                .SomeModel
                .Include(sm => sm.SubModels)
                .ThenInclude(subm => subm.SubSubModels)
                .ThenInclude(ssm => ssm.SubSubSubModels)
                .OrderByDescending(sm => sm.Title)
                .ToList();

            var someModelsSplit = db
                .SomeModel
                .AsSplitQuery()
                .Include(sm => sm.SubModels)
                .ThenInclude(subm => subm.SubSubModels)
                .ThenInclude(ssm => ssm.SubSubSubModels)
                .OrderByDescending(sm => sm.Title)
                .ToList();
        })
        .WithName("Cartesian Explosion")
        .WithOpenApi();


        group.MapGet("/cancellationtoken", async (EfCoreMistakesContext db, CancellationToken ct) =>
        {
            var someModels = await db
                .SomeModel
                .Include(sm => sm.SubModels)
                .ThenInclude(subm => subm.SubSubModels)
                .ThenInclude(ssm => ssm.SubSubSubModels)
                .OrderByDescending(sm => sm.Title)
                .TagWith("Cancellationtoken")
                .ToListAsync(ct);

            var betterModels = await db
                .SomeModel
                .AsNoTracking()
                .Select(sm => new
                {
                    sm.Id,
                    sm.Title,
                    SubModels = sm.SubModels.Select(subm => new
                    {
                        subm.Id,
                        SubSubModels = subm.SubSubModels.Select(ssm => new
                        {
                            ssm.Id,
                            SubSubSubModels = ssm.SubSubSubModels.Select(sssm => new
                            {
                                sssm.Id
                            })
                        })
                    })
                }).ToListAsync(ct);
        })
        .WithName("Cancellationtoken")
        .WithOpenApi();

        // This code demonstrates query filters in EF Core
        group.MapGet("/queryfilters", async (EfCoreMistakesContext db, CancellationToken ct) =>
        {
            // Gets filtered data based on global query filters
            var filteredData = db.SubSubModel.ToList();

            // Gets ALL data by ignoring any global query filters
            var alldData = db.SubSubModel.IgnoreQueryFilters().ToList();


        })
       .WithName("QueryFilters")
       .WithOpenApi();

        group.MapGet("/minibestpractices", async (EfCoreMistakesContext db) =>
        {
            var hasAnyModels = HasAny(db);
            var hasAnyModelsBest = HasAnyBest(db);
            // if we need data
            var hasAnyModelsBestWithData = HasAnyBestWithData(db);

            //

            // Matches on start, so uses an index
            var models1 = db.SomeModel.Where(p => p.Title.StartsWith("S")).ToList();
            // Matches on end, so does not use the index
            var models2 = db.SomeModel.Where(p => p.Title.EndsWith("S")).ToList();

            //

            // Harnessing the Perks of Compiled Queries
            var compiledQuery = EF.CompileQuery((EfCoreMistakesContext context) =>
                context.SomeModel.Where(p => p.Title.StartsWith("S")).ToList()
            );

            //

            // Embracing Raw SQL Queries for Complex Operations
            var modelId = 5;
            var model3 = db.SomeModel.FromSqlRaw("SELECT * FROM SomeModel WHERE Id = {0}", modelId).FirstOrDefault();

        })
        .WithName("Mini best practices")
        .WithOpenApi();
    }

    private static bool HasAny(EfCoreMistakesContext db)
    {
        var models = db.SomeModel
                        .Where(sm => sm.Title.StartsWith("S"))
                        .ToList();

        return models.Count > 0;
    }

    private static bool HasAnyBest(EfCoreMistakesContext db)
    {
        return db.SomeModel
            .Any(sm => sm.Title.StartsWith('S'));
    }

    private static SomeModel? HasAnyBestWithData(EfCoreMistakesContext db)
    {
        return db.SomeModel
            .FirstOrDefault(sm => sm.Title.StartsWith('S'));
    }

    private static bool SomeDotNetMethod(SomeModel p)
    {
        return true;
    }
}
